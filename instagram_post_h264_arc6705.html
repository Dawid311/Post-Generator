<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Instagram Post - MP4 H.264 Generator (ARC6705)</title>
  <link href="https://fonts.googleapis.com/css2?family=Pirata+One&display=swap" rel="stylesheet">
  <style>
    :root { --gold:#ffd700; }
    body { margin:0; font-family:'Pirata One',cursive; background:linear-gradient(135deg,#232526 0%,#1e2a38 100%); color:#fff; min-height:100vh; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:24px; padding:36px 20px 48px; box-sizing:border-box; }
    h1 { font-size:1.4rem; letter-spacing:2px; color:var(--gold); margin:0; text-shadow:0 2px 12px #000; text-align:center; }
    .card { position:relative; width:440px; max-width:95vw; background:rgba(30,40,50,.97); border-radius:18px; overflow:hidden; box-shadow:0 8px 32px rgba(0,0,0,0.5), 0 0 0 2px rgba(255,215,0,0.1); }
    .hero-image { width:100%; height:260px; background-size:cover; background-position:center; background-repeat:no-repeat; position:relative; filter:brightness(.85) grayscale(.1); background-image: url('_ARC6705.jpg'); }
  .name-mark { position:absolute; top:12px; left:14px; color:#fff; font-family:'Pirata One', cursive; font-size:28px; letter-spacing:1px; opacity:0.9; text-shadow:0 2px 10px rgba(0,0,0,0.65); user-select:none; pointer-events:none; }
    .heute-badge { position:absolute; top:15px; right:15px; background:linear-gradient(45deg, #ff6b6b, #ffd93d); color:#000; font-size:0.9rem; font-weight:bold; padding:8px 16px; border-radius:20px; text-transform:uppercase; letter-spacing:1px; box-shadow:0 4px 12px rgba(255,107,107,0.4); z-index:10; transition: transform 0.3s ease; }
    .card-content { padding:24px 20px 20px; text-align:center; position:relative; }
    .title { font-size:2.4rem; color:var(--gold); letter-spacing:2px; margin:0 0 8px; text-shadow:0 2px 16px #000a; display:flex; align-items:center; justify-content:center; gap:15px; }
    .title .music-note { font-size:1.8rem; }
    .subtitle { font-size:1.3rem; margin:0 0 12px; text-shadow:0 2px 8px #ffd70090; }
    .details { font-size:1.1rem; color:#b8c6db; letter-spacing:1px; margin:0 10px 12px; position:relative; }
    .details::before { content:"‚è∞"; margin-right:8px; color:var(--gold); }
  .cta { display:inline-block; background:linear-gradient(90deg,var(--gold),#fff); color:#232526; font-size:1.1rem; padding:10px 24px; border-radius:28px; letter-spacing:2px; text-transform:uppercase; box-shadow:0 2px 16px #ffd700a0, 0 0 20px rgba(255,215,0,0.3); position:relative; }
  /* Leere CTA nur f√ºr Live-Indikator: kein Text, kein Platzverbrauch */
  .cta.empty { background:transparent; box-shadow:none; padding:0; margin:0; border:none; letter-spacing:0; text-transform:none; position:absolute; right:20px; bottom:18px; width:auto; height:auto; }
    .cta::before { content:"üé∏"; margin-right:8px; }
    .live-indicator { position:absolute; top:-5px; right:-5px; width:12px; height:12px; background:#ff4757; border-radius:50%; transition: opacity 0.3s ease; }
  .audio-ui { margin:14px auto 0; width:90%; background:#0f1a23; border:1px solid #203040; border-radius:10px; padding:10px 12px; display:flex; align-items:center; gap:10px; height:96px; box-shadow:0 6px 18px rgba(0,0,0,0.35) inset; }
    .play-btn { width:22px; height:22px; border-radius:50%; background:#ffd93d; color:#232526; display:flex; align-items:center; justify-content:center; font-size:0.9rem; box-shadow:0 2px 10px #ffd93d66; }
    .bar-track { flex:1; height:8px; background:#16212b; border-radius:6px; overflow:hidden; position:relative; }
    .bar-fill { position:absolute; top:0; left:0; height:100%; width:30%; background:linear-gradient(90deg,var(--gold),#fff); border-radius:6px; box-shadow:0 0 10px #ffd70055 inset; }

    .status { font-size:.8rem; letter-spacing:1px; min-height:1rem; color:var(--gold); }
    .hidden { display:none!important; }
    .result { display:flex; flex-direction:column; align-items:center; gap:8px; }
    a.dl { background:#4CAF50; border:2px solid #4CAF50; color:white; padding:12px 24px; border-radius:12px; text-decoration:none; letter-spacing:1px; font-size:1rem; transition:.25s; }
    a.dl:hover { background:#45a049; box-shadow:0 0 12px #4CAF50; }
    .previewWrap { display:flex; flex-direction:column; align-items:center; gap:6px; }
    .note { font-size:.6rem; opacity:.55; text-align:center; max-width:520px; line-height:1.3; }
    .spinner { width:52px; height:52px; border:5px solid #ffffff22; border-top-color:var(--gold); border-radius:50%; animation:spin 1s linear infinite; }
    @keyframes spin { to { transform:rotate(360deg); } }
    .progress-container { width:100%; max-width:400px; background:#16212b; border-radius:10px; padding:8px; margin:16px 0; }
    .progress-bar { height:12px; background:linear-gradient(90deg,var(--gold),#fff); border-radius:6px; transition:width 0.3s ease; width:0%; }
    .progress-text { color:var(--gold); font-size:0.9rem; text-align:center; margin-top:8px; }
    .controls { display:flex; gap:10px; margin:10px; }
    .btn { background:#666; color:white; border:none; padding:8px 16px; border-radius:5px; cursor:pointer; font-size:12px; transition:.25s; }
    .btn:hover { background:#555; }
    .btn.start { background:#4CAF50; }
    .btn.start:hover { background:#45a049; }
    .btn.force { background:#ff6b6b; }
    .btn.force:hover { background:#ff5252; }
    .format-info { background:rgba(255,215,0,0.1); border:1px solid var(--gold); padding:8px; border-radius:8px; font-size:0.7rem; margin:10px 0; }
  </style>
</head>
<body>
  <h1>Instagram Post - H.264 MP4 Generator (ARC6705)</h1>
  <div class="status" id="status">Bereit - Klicken Sie START!</div>
  <div class="format-info">
    üì± Erstellt animiertes Instagram MP4 - ca. 8 Sekunden (ohne Audio)
  </div>
  <div class="controls">
    <button class="btn start" id="startBtn" onclick="startExport()">üé¨ START - Animiertes MP4 (8s)</button>
    <button class="btn" onclick="location.reload()">üîÑ Neu starten</button>
    <button class="btn force" onclick="forceRestart()">‚ö†Ô∏è Force Reset</button>
  </div>

  <div class="card" id="captureTarget">
  <div class="hero-image">
  <div class="name-mark">Dawid Faith</div>
  </div>
    <div class="card-content">
      <div class="title">
        <span class="music-note">üéµ</span>
        <span>KONZERT</span>
        <span class="music-note">üéµ</span>
      </div>
      <div class="subtitle">29.08 ‚Ä¢ 19:00 Uhr</div>
      <div class="details">Katys Garage, Dresden Neustadt<br>Live-Musik & Atmosph√§re</div>
  <!-- Live-Indikator entfernt -->
  <div class="audio-ui" id="audioSim"></div>
    </div>
  </div>

  <div class="spinner" id="spinner"></div>
  <div class="progress-container hidden" id="progressContainer">
    <div class="progress-bar" id="progressBar"></div>
    <div class="progress-text" id="progressText">0%</div>
  </div>

  <div class="result hidden" id="result">
    <div class="previewWrap">
      <img id="gifPreview" style="max-width:260px; border:2px solid var(--gold); border-radius:12px;" />
      <video id="videoPreview" controls style="max-width:260px; border:2px solid var(--gold); border-radius:12px; margin-top:10px;" muted></video>
      <div style="margin-top:8px; font-size:0.7rem; opacity:0.7;">
        <span id="videoInfo">Video-Info wird geladen...</span>
      </div>
    </div>
    <a class="dl" id="dlGif" download="instagram_post_frame.png">üé® Download Animation Frame</a>
    <a class="dl" id="dlMp4" download="instagram_post_8s.mp4" style="margin-top:8px;">üì± Download Instagram MP4 (H.264)</a>
  </div>
  <p class="note">Erstellt Instagram-kompatibles H.264 MP4 - ca. 8 Sekunden.</p>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    let isRecording = false;
    let recordingStartTime = 0;
    let mediaRecorder = null;
    let recordingTimer = null;

    function startExport() {
      if (isRecording) return;
      const startBtn = document.getElementById('startBtn');
      const statusEl = document.getElementById('status');
      startBtn.style.display = 'none';
      statusEl.textContent = 'Wird gestartet...';
      isRecording = true;
      setTimeout(autoExport, 100);
    }

    async function autoExport(){
      const statusEl=document.getElementById('status');
      const spinner=document.getElementById('spinner');
      const progressContainer=document.getElementById('progressContainer');
      const progressBar=document.getElementById('progressBar');
      const progressText=document.getElementById('progressText');
      const result=document.getElementById('result');
      const dlGif=document.getElementById('dlGif');
      const dlMp4=document.getElementById('dlMp4');
      const target=document.getElementById('captureTarget');
      const gifPreview=document.getElementById('gifPreview');
  const videoPreview=document.getElementById('videoPreview');

      try {
        statusEl.textContent='Vorbereitung...';
        await (document.fonts?.ready||Promise.resolve());
        await new Promise(r=>setTimeout(r,500));

  // Keine DOM-Progressbar mehr (entfernt)

        spinner.classList.add('hidden');
        progressContainer.classList.remove('hidden');

        progressBar.style.width = '20%';
        progressText.textContent = '20% - Frame wird erfasst...';
        statusEl.textContent = 'Animation Frame wird erfasst...';

        const canvas = await html2canvas(target, {
          backgroundColor: null,
          scale: 2.0,
          useCORS: true,
          allowTaint: true,
          logging: false
        });

        canvas.toBlob(function(blob) {
          const gifUrl = URL.createObjectURL(blob);
          gifPreview.src = gifUrl;
          dlGif.href = gifUrl;
        }, 'image/png');

        progressBar.style.width = '30%';
        progressText.textContent = '30% - Instagram MP4 wird erstellt...';
        statusEl.textContent = 'Instagram-kompatibles MP4 wird erstellt...';

  await createInstagramMP4(canvas);
      } catch(e){ 
        console.error(e); 
        statusEl.textContent='Fehler: '+e.message; 
        spinner.classList.add('hidden'); 
        progressContainer.classList.add('hidden');
        isRecording = false;
      }
    }

    async function createInstagramMP4(frameCanvas) {
      const statusEl=document.getElementById('status');
      const progressBar=document.getElementById('progressBar');
      const progressText=document.getElementById('progressText');
      const result=document.getElementById('result');
      const dlMp4=document.getElementById('dlMp4');
      const videoPreview=document.getElementById('videoPreview');
      const videoInfo=document.getElementById('videoInfo');
      const progressContainer=document.getElementById('progressContainer');
  const badge=document.getElementById('badge');
  const indicator=document.getElementById('indicator');
      const targetEl=document.getElementById('captureTarget');
      const audioSim=document.getElementById('audioSim');

      try {
        const W = 1080, H = 1350; // Instagram 4:5
        const videoCanvas = document.createElement('canvas');
        videoCanvas.width = W; videoCanvas.height = H;
        const videoCtx = videoCanvas.getContext('2d');
        videoCtx.imageSmoothingEnabled = true;
        videoCtx.imageSmoothingQuality = 'high';

        const stream = videoCanvas.captureStream(60);
        let videoChunks = [];

        // Canvas-Positionen (DOM -> Frame)
        let indicatorCanvasPos = null; // {x,y,r}
  let badgeCanvasRect = null;    // {x,y,w,h}
        let audioCanvasRect = null;    // {x,y,w,h}
        try {
          const tRect = targetEl.getBoundingClientRect();
          const scaleX = frameCanvas.width / tRect.width;
          const scaleY = frameCanvas.height / tRect.height;
          // Kein Live-Indikator mehr ‚Äì keine Position berechnen
          indicatorCanvasPos = null;

          // Kein Badge mehr: nicht zeichnen
          badgeCanvasRect = null;

          const aRect = audioSim.getBoundingClientRect();
          audioCanvasRect = {
            x: (aRect.left - tRect.left) * scaleX,
            y: (aRect.top - tRect.top) * scaleY,
            w: aRect.width * scaleX,
            h: aRect.height * scaleY
          };
        } catch(e) {
          console.warn('Fallback-Overlay-Positionen', e);
          // Kein Live-Indikator-Fallback
          indicatorCanvasPos = null;
          // Kein Badge-Fallback, bleibt entfernt
          badgeCanvasRect = null;
          audioCanvasRect = { x: frameCanvas.width*0.06, y: frameCanvas.height*0.77, w: frameCanvas.width*0.88, h: frameCanvas.height*0.10 };
        }

        const supportedTypes = [
          'video/mp4;codecs=h264', 'video/mp4;codecs=avc1', 'video/mp4',
          'video/webm;codecs=h264', 'video/webm;codecs=vp9', 'video/webm'
        ];
        let selectedMimeType = 'video/webm';
        for (const type of supportedTypes) {
          if (MediaRecorder.isTypeSupported(type)) { selectedMimeType = type; break; }
        }

        mediaRecorder = new MediaRecorder(stream, { mimeType: selectedMimeType, videoBitsPerSecond: 2000000 });
        mediaRecorder.ondataavailable = e => { if (e.data.size > 0) videoChunks.push(e.data); };
        mediaRecorder.onstop = () => {
          const actualDuration = (Date.now() - recordingStartTime) / 1000;
          if (recordingTimer) { clearInterval(recordingTimer); recordingTimer = null; }

          const blobType = selectedMimeType.split(';')[0];
          const videoBlob = new Blob(videoChunks, { type: blobType });
          const videoUrl = URL.createObjectURL(videoBlob);
          const isMp4 = videoBlob.type === 'video/mp4';
          const ext = isMp4 ? 'mp4' : 'webm';
          const sizeMB = (videoBlob.size/1024/1024).toFixed(1);

          dlMp4.href = videoUrl;
          dlMp4.download = `instagram_post_arc6705_${Math.round(actualDuration)}s.${ext}`;
          dlMp4.textContent = isMp4 ? 'üì± Download Instagram MP4 (H.264)' : 'üì± Download Instagram WEBM';
          dlMp4.title = isMp4 ? 'MP4 (H.264) wurde erstellt' : 'Dein Browser unterst√ºtzt MP4-Aufnahme nicht direkt ‚Äì WEBM wurde erstellt';
          videoPreview.src = videoUrl;

          const videoInfo = document.getElementById('videoInfo');
          if (videoInfo) videoInfo.textContent = `${actualDuration.toFixed(1)}s, ${sizeMB}MB (${videoBlob.type}) - Animiert`;

          result.classList.remove('hidden');
          progressContainer.classList.add('hidden');
          isRecording = false;

          setTimeout(()=>{ try{ dlMp4.click(); }catch(_){} }, 400);
        };

  // Aufnahme starten
  const maxDuration = 8000; // 8s
        recordingStartTime = Date.now();
        mediaRecorder.start(100);

        // Fortschrittstimer
        recordingTimer = setInterval(() => {
          const elapsed = Date.now() - recordingStartTime;
          if (elapsed >= maxDuration) {
            // Timer h√§lt an; Stop erfolgt nach finalem Zeichnen in rAF
            clearInterval(recordingTimer); recordingTimer = null;
            return;
          }
          const progress = Math.min(elapsed / maxDuration, 1) * 70 + 30;
          progressBar.style.width = progress + '%';
          progressText.textContent = `${Math.round(progress)}% - MP4: ${(elapsed/1000).toFixed(1)}s / 8.0s`;
          statusEl.textContent = `Instagram MP4: ${(elapsed/1000).toFixed(1)}s / 8.0s`;
        }, 100);

        // Zeichen-Schleife: statischer Post + animierte Symbole/Audio
        let stoppedAfterFinal = false;
        const animate = () => {
          const now = Date.now();
          const elapsed = now - recordingStartTime;
          const clampedElapsed = Math.min(elapsed, maxDuration - 16); // ca. letzter Frame ~ 60 FPS
          const time = Math.max(0, clampedElapsed) / 1000;

          // Hintergrund statisch
          const grd = videoCtx.createLinearGradient(0, 0, W, H);
          grd.addColorStop(0,'#232526'); grd.addColorStop(0.3,'#2a3439'); grd.addColorStop(0.7,'#1e2a38'); grd.addColorStop(1,'#1a252f');
          videoCtx.fillStyle = grd; videoCtx.fillRect(0,0,W,H);

          // Statischer Frame rendern (ohne Bewegung)
          const baseScale = Math.min(W * 0.9 / frameCanvas.width, H * 0.75 / frameCanvas.height);
          const drawW = frameCanvas.width * baseScale; const drawH = frameCanvas.height * baseScale;
          const dx = (W - drawW) / 2; const dy = (H - drawH) / 2;
          videoCtx.drawImage(frameCanvas, dx, dy, drawW, drawH);

          const animTime = time * 2;

          // Live-Indikator (Puls)
          if (indicatorCanvasPos) {
            const ix = dx + indicatorCanvasPos.x * baseScale;
            const iy = dy + indicatorCanvasPos.y * baseScale;
            const ir = indicatorCanvasPos.r * baseScale * (0.9 + 0.35 * Math.sin(animTime * 2));
            const pulse = 0.65 + 0.35 * (0.5 + 0.5 * Math.sin(animTime * Math.PI * 1.5));
            videoCtx.save(); videoCtx.globalAlpha = 0.6 * pulse; videoCtx.fillStyle = '#ff6b6b'; videoCtx.shadowColor = '#ff4757'; videoCtx.shadowBlur = 18;
            videoCtx.beginPath(); videoCtx.arc(ix, iy, ir * 1.6, 0, Math.PI * 2); videoCtx.fill(); videoCtx.restore();
            videoCtx.save(); videoCtx.globalAlpha = 0.9; videoCtx.fillStyle = '#ff4757'; videoCtx.beginPath(); videoCtx.arc(ix, iy, ir, 0, Math.PI * 2); videoCtx.fill(); videoCtx.restore();
          }

          // Badge entfernt ‚Äì keine Zeichnung

          // Simulierter Audio-Player: Panel + Equalizer + Label
          if (audioCanvasRect) {
            const ax = dx + audioCanvasRect.x * baseScale;
            const ay = dy + audioCanvasRect.y * baseScale;
            const aw = audioCanvasRect.w * baseScale;
            const ah = audioCanvasRect.h * baseScale;

            // Panel-Hintergrund mit abgerundeten Ecken
            const r = Math.min(12, ah * 0.18);
            const panelGrad = videoCtx.createLinearGradient(ax, ay, ax, ay + ah);
            panelGrad.addColorStop(0, '#0f1a23');
            panelGrad.addColorStop(1, '#152635');
            videoCtx.save();
            videoCtx.fillStyle = panelGrad;
            videoCtx.strokeStyle = '#203040';
            videoCtx.lineWidth = Math.max(1, ah * 0.02);
            videoCtx.beginPath();
            videoCtx.moveTo(ax + r, ay);
            videoCtx.lineTo(ax + aw - r, ay);
            videoCtx.quadraticCurveTo(ax + aw, ay, ax + aw, ay + r);
            videoCtx.lineTo(ax + aw, ay + ah - r);
            videoCtx.quadraticCurveTo(ax + aw, ay + ah, ax + aw - r, ay + ah);
            videoCtx.lineTo(ax + r, ay + ah);
            videoCtx.quadraticCurveTo(ax, ay + ah, ax, ay + ah - r);
            videoCtx.lineTo(ax, ay + r);
            videoCtx.quadraticCurveTo(ax, ay, ax + r, ay);
            videoCtx.fill();
            videoCtx.stroke();
            videoCtx.restore();

            // Equalizer-Balken (gr√∂√üer und breiter)
            const pad = 14 * (aw/600); // adaptive Padding
            const eqX = ax + pad;
            const eqW = aw - pad*2;
            const bars = 18;
            const gap = Math.max(3, eqW * 0.005);
            const bw = (eqW - (bars-1)*gap) / bars;
            const baseH = ah * 0.56;
            const baseY = ay + (ah * 0.55) - baseH; // zentrierter Eindruck
            for (let i=0;i<bars;i++){
              const phase = i * 0.5;
              const h = baseH * (0.4 + 0.6 * (0.5 + 0.5 * Math.sin(time*3 + phase)));
              const x = eqX + i * (bw + gap);
              const y = baseY + (baseH - h);
              videoCtx.fillStyle = i % 3 === 0 ? '#ffd93d' : '#b8c6db';
              videoCtx.fillRect(x, y, bw, h);
            }

            // Label: ‚Äû‚ô´ Song l√§uft‚Äú
            const labelPx = Math.max(16, ah * 0.20);
            videoCtx.save();
            videoCtx.fillStyle = '#b8c6db';
            videoCtx.font = `bold ${labelPx}px 'Pirata One', sans-serif`;
            videoCtx.textAlign = 'left';
            videoCtx.textBaseline = 'alphabetic';
            videoCtx.fillText('‚ô´ Song l√§uft', eqX, ay + ah - Math.max(10, ah*0.12));
            videoCtx.restore();

            // Kein Play-Button mehr
          }

          if (elapsed >= maxDuration) {
            // Nach finalem Zeichnen Recorder stoppen (ein Frame sicher vorhanden)
            if (!stoppedAfterFinal && mediaRecorder && mediaRecorder.state === 'recording') {
              stoppedAfterFinal = true;
              setTimeout(() => {
                try { mediaRecorder.stop(); } catch(_) {}
              }, 0);
            }
            return; // keine weiteren rAFs
          }

          requestAnimationFrame(animate);
        };
        animate();

      } catch(e) {
        console.error('MP4 Fehler:', e);
        statusEl.textContent = 'MP4 Fehler: ' + e.message;
        progressContainer.classList.add('hidden');
        isRecording = false;
      }
    }

    function forceRestart() {
      if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
      if (recordingTimer) { clearInterval(recordingTimer); recordingTimer = null; }
      isRecording = false;
      const statusEl=document.getElementById('status');
      const spinner=document.getElementById('spinner');
      const progressContainer=document.getElementById('progressContainer');
      const result=document.getElementById('result');
      const startBtn=document.getElementById('startBtn');
      statusEl.textContent = 'Wird zur√ºckgesetzt...';
      spinner.classList.remove('hidden');
      progressContainer.classList.add('hidden');
      result.classList.add('hidden');
      startBtn.style.display = 'inline-block';
      setTimeout(() => { location.reload(); }, 500);
    }

    window.addEventListener('error', function(e) {
      console.error('Globaler Fehler:', e);
      const statusEl=document.getElementById('status');
      statusEl.textContent = 'Unerwarteter Fehler - bitte neu starten';
      isRecording = false;
    });

    window.addEventListener('load', ()=>{ 
      console.log('üé¨ Instagram H.264 MP4 Generator (ARC6705) bereit');
      const types = ['video/mp4;codecs=h264', 'video/mp4', 'video/webm;codecs=h264', 'video/webm'];
      console.log('Verf√ºgbare Video-Formate:');
      types.forEach(type => { console.log(`${type}: ${MediaRecorder.isTypeSupported(type) ? '‚úÖ' : '‚ùå'}`); });
    });
  </script>
</body>
</html>
